/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["SWQ"] = factory();
	else
		root["SWQ"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/swq.js":
/*!***********************!*\
  !*** ./src/js/swq.js ***!
  \***********************/
/***/ ((module) => {

eval("{(function (window) {\n  'use strict';\n\n  // Main library object\n  const swq = {\n    instances: [],\n    init: function (selector, options = {}) {\n      const elements = document.querySelectorAll(selector);\n      elements.forEach(el => {\n        // Prevent re-initialization\n        if (!el.swq) {\n          this.instances.push(new Quiz(el, options));\n        }\n      });\n      return this.instances;\n    }\n  };\n\n  /**\r\n   * The Core Quiz Class\r\n   */\n  class Quiz {\n    constructor(element, options = {}) {\n      this.element = element;\n      this.element.swq = this; // Mark as initialized\n      this.options = options;\n      this._parseConfig();\n      this._parseQuestions();\n      this._setupUI();\n      this.state = {\n        currentIndex: -1,\n        userAnswers: {},\n        // { qId: { answer, isCorrect } }\n        isFinished: false,\n        startTime: null,\n        timerId: null\n      };\n      this._startQuiz();\n    }\n\n    // --- Private Methods: Setup & Parsing ---\n\n    _parseConfig() {\n      const defaults = {\n        feedbackMode: 'standard',\n        // standard, immediate, retry\n        allowSkip: false,\n        allowBack: false,\n        timer: 0 // in seconds\n      };\n      const dataAttrs = {};\n      for (const key in this.element.dataset) {\n        if (key.startsWith('swq')) {\n          let camelCaseKey = key.substring(3).replace(/-(\\w)/g, (match, letter) => letter.toUpperCase());\n          camelCaseKey = camelCaseKey.charAt(0).toLowerCase() + camelCaseKey.slice(1);\n          let value = this.element.dataset[key];\n          if (value === 'true') value = true;\n          if (value === 'false') value = false;\n          if (!isNaN(parseFloat(value)) && isFinite(value)) value = parseFloat(value);\n          dataAttrs[camelCaseKey] = value;\n        }\n      }\n      this.config = {\n        ...defaults,\n        ...dataAttrs,\n        ...(this.options.settings || {})\n      };\n    }\n    _parseQuestions() {\n      if (this.options.questions && Array.isArray(this.options.questions)) {\n        this.questions = this.options.questions;\n      } else {\n        this.questions = [];\n        const questionElements = this.element.querySelectorAll('[data-swq-question-id]');\n        questionElements.forEach(qEl => {\n          const typeEl = qEl.querySelector('[data-swq-type]');\n          if (!typeEl) {\n            console.warn(`Question ${qEl.dataset.swqQuestionId} is missing data-swq-type attribute`);\n            return;\n          }\n          const questionTextEl = qEl.querySelector('p');\n          if (!questionTextEl) {\n            console.warn(`Question ${qEl.dataset.swqQuestionId} is missing question text`);\n            return;\n          }\n          const question = {\n            id: qEl.dataset.swqQuestionId,\n            text: questionTextEl.innerHTML,\n            type: typeEl.dataset.swqType,\n            answer: typeEl.dataset.swqAnswer,\n            options: typeEl.dataset.swqOptions ? JSON.parse(typeEl.dataset.swqOptions) : []\n          };\n\n          // Validate required fields\n          if (!question.answer && question.type !== 'text') {\n            console.warn(`Question ${question.id} is missing answer attribute`);\n            return;\n          }\n          this.questions.push(question);\n        });\n      }\n    }\n    _setupUI() {\n      this.ui = {\n        nextBtn: this.element.querySelector('[data-swq-next]'),\n        prevBtn: this.element.querySelector('[data-swq-previous]'),\n        checkAnswerBtn: this.element.querySelector('[data-swq-check-answer]'),\n        skipBtn: this.element.querySelector('[data-swq-skip-question]'),\n        timerDisplay: this.element.querySelector('[data-swq-timer]'),\n        resultsContainer: this.element.querySelector('[data-swq-results]'),\n        questionsContainer: this.element.querySelector('[data-swq-answers]') || this.element\n      };\n\n      // Fallback: Create default controls if not provided\n      if (!this.ui.nextBtn && !this.ui.prevBtn && !this.ui.checkAnswerBtn) {\n        const controlsContainer = document.createElement('div');\n        controlsContainer.className = 'swq-controls-default';\n        if (this.config.allowBack) {\n          this.ui.prevBtn = document.createElement('button');\n          this.ui.prevBtn.textContent = 'Previous';\n          this.ui.prevBtn.setAttribute('data-swq-previous', '');\n          controlsContainer.appendChild(this.ui.prevBtn);\n        }\n        this.ui.nextBtn = document.createElement('button');\n        this.ui.nextBtn.textContent = 'Next';\n        this.ui.nextBtn.setAttribute('data-swq-next', '');\n        controlsContainer.appendChild(this.ui.nextBtn);\n        this.element.appendChild(controlsContainer);\n      }\n\n      // Fallback: Create default timer if needed and not provided\n      if (this.config.timer > 0 && !this.ui.timerDisplay) {\n        this.ui.timerDisplay = document.createElement('div');\n        this.ui.timerDisplay.className = 'swq-timer-default';\n        this.ui.timerDisplay.setAttribute('data-swq-timer', '');\n        this.element.insertBefore(this.ui.timerDisplay, this.ui.questionsContainer);\n      }\n\n      // Fallback: Create default results container if not provided\n      if (!this.ui.resultsContainer) {\n        this.ui.resultsContainer = document.createElement('div');\n        this.ui.resultsContainer.className = 'swq-results-default';\n        this.ui.resultsContainer.setAttribute('data-swq-results', '');\n        this.element.appendChild(this.ui.resultsContainer);\n      }\n\n      // Add event listeners\n      if (this.ui.nextBtn) this.ui.nextBtn.addEventListener('click', () => this._handleNext());\n      if (this.ui.prevBtn) this.ui.prevBtn.addEventListener('click', () => this._handlePrevious());\n      if (this.ui.checkAnswerBtn) this.ui.checkAnswerBtn.addEventListener('click', () => this._handleCheckAnswer());\n      if (this.ui.skipBtn) this.ui.skipBtn.addEventListener('click', () => this._handleSkip());\n    }\n\n    // --- Public Methods & Core Logic ---\n\n    _startQuiz() {\n      if (this.state.isFinished || this.questions.length === 0) return;\n      this.state.startTime = Date.now();\n      if (this.config.timer > 0) {\n        this._updateTimerDisplay();\n        this.state.timerId = setInterval(() => this._updateTimer(), 1000);\n      }\n      this._renderQuestion(0);\n      if (typeof this.config.onStart === 'function') {\n        this.config.onStart.call(this);\n      }\n    }\n    _endQuiz(reason = 'completed') {\n      if (this.state.isFinished) return;\n      this.state.isFinished = true;\n      clearInterval(this.state.timerId);\n\n      // In standard mode, show all feedback now\n      if (this.config.feedbackMode === 'standard') {\n        this.questions.forEach(question => {\n          const qElement = this._getOrCreateQuestionElement(question.id);\n          const userAnswerData = this.state.userAnswers[question.id];\n          if (userAnswerData) {\n            qElement.classList.add(userAnswerData.isCorrect ? 'swq-correct' : 'swq-incorrect');\n            this._showFeedback(question, userAnswerData.isCorrect);\n          }\n        });\n      }\n\n      // Hide quiz questions but not the entire container\n      Array.from(this.ui.questionsContainer.children).forEach(child => {\n        if (child.dataset.swqQuestionId) {\n          child.style.display = 'none';\n        }\n      });\n\n      // Hide all control buttons and timer, but keep the container visible\n      if (this.ui.nextBtn) this.ui.nextBtn.style.display = 'none';\n      if (this.ui.prevBtn) this.ui.prevBtn.style.display = 'none';\n      if (this.ui.checkAnswerBtn) this.ui.checkAnswerBtn.style.display = 'none';\n      if (this.ui.skipBtn) this.ui.skipBtn.style.display = 'none';\n      if (this.ui.timerDisplay) this.ui.timerDisplay.style.display = 'none';\n\n      // Calculate score\n      let score = 0;\n      this.questions.forEach(q => {\n        const userAnswerData = this.state.userAnswers[q.id];\n        if (userAnswerData && userAnswerData.isCorrect) {\n          score++;\n        }\n      });\n      const results = {\n        score: score,\n        total: this.questions.length,\n        percentage: this.questions.length > 0 ? Math.round(score / this.questions.length * 100) : 0,\n        reason: reason // 'completed' or 'time_up'\n      };\n\n      // Display results\n      this.ui.resultsContainer.innerHTML = `\n                <div class=\"swq-result-summary\">\n                    <h3>Quiz Complete!</h3>\n                    <p>You scored <strong>${results.score} out of ${results.total}</strong> (${results.percentage}%).</p>\n                    ${reason === 'time_up' ? '<p>Time ran out!</p>' : ''}\n                </div>\n            `;\n      this.ui.resultsContainer.style.display = 'block';\n      if (typeof this.config.onComplete === 'function') {\n        this.config.onComplete.call(this, results);\n      }\n    }\n\n    // --- UI Rendering & State Management ---\n\n    _renderQuestion(index) {\n      if (index < 0 || index >= this.questions.length) return;\n      this.state.currentIndex = index;\n      const question = this.questions[index];\n      const questionElement = this._getOrCreateQuestionElement(question.id);\n\n      // Hide all other questions\n      Array.from(this.ui.questionsContainer.children).forEach(child => {\n        if (child.dataset.swqQuestionId) child.style.display = 'none';\n      });\n\n      // Check if the question needs to be built (look for options container instead of just innerHTML)\n      const optionsContainer = questionElement.querySelector('.swq-options-container');\n      if (!optionsContainer || optionsContainer.children.length === 0) {\n        // Find the existing div with data-swq-type and replace it with built HTML\n        const typeEl = questionElement.querySelector('[data-swq-type]');\n        if (typeEl) {\n          typeEl.outerHTML = this._buildQuestionHTML(question);\n        } else if (!questionElement.innerHTML.trim()) {\n          questionElement.innerHTML = this._buildQuestionHTML(question);\n        }\n      }\n      questionElement.style.display = 'block';\n      questionElement.classList.add('swq-active');\n      this._restoreAnswer(question.id);\n      this._updateControls();\n      if (typeof this.config.onQuestionChange === 'function') {\n        this.config.onQuestionChange.call(this, question, index);\n      }\n    }\n    _getOrCreateQuestionElement(id) {\n      let el = this.ui.questionsContainer.querySelector(`[data-swq-question-id=\"${id}\"]`);\n      if (!el) {\n        el = document.createElement('div');\n        el.dataset.swqQuestionId = id;\n        el.className = 'swq-question';\n        this.ui.questionsContainer.appendChild(el);\n      }\n      return el;\n    }\n    _buildQuestionHTML(question) {\n      let optionsHTML = '';\n      const questionName = `swq-q-${question.id}`;\n      switch (question.type) {\n        case 'choice':\n        case 'true/false':\n          const options = question.type === 'true/false' ? ['True', 'False'] : question.options;\n          optionsHTML = options.map(opt => `\n                        <label class=\"swq-option\">\n                            <input type=\"radio\" name=\"${questionName}\" value=\"${opt}\" onchange=\"this.closest('[data-swq-quiz]').swq._updateControls()\">\n                            <span>${opt}</span>\n                        </label>\n                    `).join('');\n          break;\n        case 'select-multiple':\n          optionsHTML = question.options.map(opt => `\n                        <label class=\"swq-option\">\n                            <input type=\"checkbox\" name=\"${questionName}\" value=\"${opt}\" onchange=\"this.closest('[data-swq-quiz]').swq._updateControls()\">\n                            <span>${opt}</span>\n                        </label>\n                    `).join('');\n          break;\n        case 'text':\n          optionsHTML = `<input type=\"text\" name=\"${questionName}\" class=\"swq-input\" oninput=\"this.closest('[data-swq-quiz]').swq._updateControls()\">`;\n          break;\n        case 'number':\n          optionsHTML = `<input type=\"number\" name=\"${questionName}\" class=\"swq-input\" oninput=\"this.closest('[data-swq-quiz]').swq._updateControls()\">`;\n          break;\n      }\n\n      // Check if we're building a complete question or just replacing options\n      const callingElement = this.ui.questionsContainer.querySelector(`[data-swq-question-id=\"${question.id}\"]`);\n      const hasExistingText = callingElement && callingElement.querySelector('p');\n      if (hasExistingText) {\n        // Just return the options container for replacement\n        return `\n                    <div class=\"swq-options-container\" data-swq-type=\"${question.type}\">${optionsHTML}</div>\n                    <div class=\"swq-feedback\"></div>\n                `;\n      } else {\n        // Return complete question HTML\n        return `\n                    <p class=\"swq-question-text\">${question.text}</p>\n                    <div class=\"swq-options-container\" data-swq-type=\"${question.type}\">${optionsHTML}</div>\n                    <div class=\"swq-feedback\"></div>\n                `;\n      }\n    }\n    _updateControls() {\n      const {\n        currentIndex\n      } = this.state;\n      const totalQuestions = this.questions.length;\n      const currentQuestionEl = this._getOrCreateQuestionElement(this.questions[currentIndex]?.id);\n\n      // Previous button\n      if (this.ui.prevBtn) {\n        this.ui.prevBtn.disabled = currentIndex <= 0 || !this.config.allowBack;\n      }\n\n      // Check if user has provided an answer\n      const answer = this._collectAnswer();\n      const hasAnswer = Array.isArray(answer) ? answer.length > 0 : answer !== null && answer !== '' && answer !== undefined;\n      const isLastQuestion = currentIndex === totalQuestions - 1;\n\n      // Handle custom check answer button\n      if (this.ui.checkAnswerBtn) {\n        this.ui.checkAnswerBtn.disabled = !hasAnswer;\n\n        // Update button text based on feedback mode and current state\n        if (this.config.feedbackMode === 'retry' && currentQuestionEl.classList.contains('swq-incorrect')) {\n          this.ui.checkAnswerBtn.textContent = 'Try Again';\n        } else if (currentQuestionEl.classList.contains('swq-correct')) {\n          this.ui.checkAnswerBtn.textContent = isLastQuestion ? 'Finish Quiz' : 'Continue';\n        } else {\n          this.ui.checkAnswerBtn.textContent = 'Submit Answer';\n        }\n      }\n\n      // Handle skip button\n      if (this.ui.skipBtn) {\n        this.ui.skipBtn.disabled = !this.config.allowSkip;\n        this.ui.skipBtn.textContent = isLastQuestion ? 'Skip to Results' : 'Skip Question';\n      }\n\n      // Handle next button (if using default controls)\n      if (this.ui.nextBtn) {\n        // Determine button text based on feedback mode and current state\n        if (this.config.feedbackMode === 'retry' && currentQuestionEl.classList.contains('swq-incorrect')) {\n          this.ui.nextBtn.textContent = 'Try Again';\n        } else if (this.config.feedbackMode === 'immediate') {\n          this.ui.nextBtn.textContent = isLastQuestion ? 'Finish Quiz' : 'Next Question';\n        } else {\n          this.ui.nextBtn.textContent = isLastQuestion ? 'Finish Quiz' : 'Next';\n        }\n\n        // Only disable next button if no answer is given AND skipping is not allowed\n        this.ui.nextBtn.disabled = !hasAnswer && !this.config.allowSkip;\n      }\n    }\n    _updateTimer() {\n      const elapsed = Math.floor((Date.now() - this.state.startTime) / 1000);\n      const remaining = this.config.timer - elapsed;\n      if (remaining <= 0) {\n        this._endQuiz('time_up');\n      } else {\n        this._updateTimerDisplay(remaining);\n      }\n    }\n    _updateTimerDisplay(seconds = this.config.timer) {\n      if (!this.ui.timerDisplay) return;\n      const minutes = Math.floor(seconds / 60);\n      const remainingSeconds = seconds % 60;\n      this.ui.timerDisplay.textContent = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\n    }\n\n    // --- Answer Handling ---\n\n    _handleNext() {\n      const question = this.questions[this.state.currentIndex];\n      const answer = this._collectAnswer();\n      const qElement = this._getOrCreateQuestionElement(question.id);\n      qElement.classList.remove('swq-incorrect', 'swq-correct');\n      const isCorrect = this._isAnswerCorrect(question, answer);\n      this.state.userAnswers[question.id] = {\n        answer,\n        isCorrect\n      };\n\n      // Handle feedback modes\n      if (this.config.feedbackMode === 'immediate') {\n        // Show feedback immediately and disable inputs\n        qElement.classList.add(isCorrect ? 'swq-correct' : 'swq-incorrect');\n        this._showFeedback(question, isCorrect);\n        qElement.querySelectorAll('input').forEach(input => input.disabled = true);\n\n        // Always advance to next question in immediate mode\n        if (this.state.currentIndex < this.questions.length - 1) {\n          this._renderQuestion(this.state.currentIndex + 1);\n        } else {\n          this._endQuiz();\n        }\n      } else if (this.config.feedbackMode === 'retry') {\n        // Show feedback but allow retry if wrong\n        qElement.classList.add(isCorrect ? 'swq-correct' : 'swq-incorrect');\n        this._showFeedback(question, isCorrect);\n        if (!isCorrect) {\n          // Don't advance, allow user to try again\n          this._updateControls(); // Update button to say \"Check Answer\"\n          return;\n        } else {\n          // Correct answer, advance\n          if (this.state.currentIndex < this.questions.length - 1) {\n            this._renderQuestion(this.state.currentIndex + 1);\n          } else {\n            this._endQuiz();\n          }\n        }\n      } else {\n        // Standard mode - no feedback until end, just advance\n        if (this.state.currentIndex < this.questions.length - 1) {\n          this._renderQuestion(this.state.currentIndex + 1);\n        } else {\n          this._endQuiz();\n        }\n      }\n    }\n    _handlePrevious() {\n      if (this.config.allowBack && this.state.currentIndex > 0) {\n        this._renderQuestion(this.state.currentIndex - 1);\n      }\n    }\n    _handleCheckAnswer() {\n      const question = this.questions[this.state.currentIndex];\n      const answer = this._collectAnswer();\n      const qElement = this._getOrCreateQuestionElement(question.id);\n\n      // Don't process if no answer is provided\n      if (answer === null || answer === '' || Array.isArray(answer) && answer.length === 0) {\n        return;\n      }\n      qElement.classList.remove('swq-incorrect', 'swq-correct');\n      const isCorrect = this._isAnswerCorrect(question, answer);\n      this.state.userAnswers[question.id] = {\n        answer,\n        isCorrect\n      };\n\n      // Show feedback based on feedback mode\n      if (this.config.feedbackMode !== 'standard') {\n        qElement.classList.add(isCorrect ? 'swq-correct' : 'swq-incorrect');\n        this._showFeedback(question, isCorrect);\n        if (this.config.feedbackMode === 'immediate') {\n          qElement.querySelectorAll('input').forEach(input => input.disabled = true);\n        }\n      }\n      this._updateControls();\n    }\n    _handleSkip() {\n      if (!this.config.allowSkip) return;\n      const question = this.questions[this.state.currentIndex];\n\n      // Record skipped answer\n      this.state.userAnswers[question.id] = {\n        answer: null,\n        isCorrect: false,\n        skipped: true\n      };\n\n      // Move to next question or end quiz\n      if (this.state.currentIndex < this.questions.length - 1) {\n        this._renderQuestion(this.state.currentIndex + 1);\n      } else {\n        this._endQuiz();\n      }\n    }\n    _collectAnswer() {\n      const question = this.questions[this.state.currentIndex];\n      const qElement = this._getOrCreateQuestionElement(question.id);\n      const name = `swq-q-${question.id}`;\n      switch (question.type) {\n        case 'choice':\n        case 'true/false':\n          const checkedRadio = qElement.querySelector(`input[name=\"${name}\"]:checked`);\n          return checkedRadio ? checkedRadio.value : null;\n        case 'select-multiple':\n          const checkedBoxes = Array.from(qElement.querySelectorAll(`input[name=\"${name}\"]:checked`));\n          return checkedBoxes.map(cb => cb.value);\n        case 'text':\n        case 'number':\n          const input = qElement.querySelector(`input[name=\"${name}\"]`);\n          return input ? input.value : null;\n      }\n      return null;\n    }\n    _isAnswerCorrect(question, userAnswer) {\n      if (userAnswer === null || userAnswer === '' || userAnswer === undefined) return false;\n      if (!question.answer) return false; // Add this check\n\n      const correctAnswer = question.answer.toString();\n      switch (question.type) {\n        case 'select-multiple':\n          const correctAnswers = correctAnswer.split(',').map(s => s.trim()).sort();\n          const userAnswers = Array.isArray(userAnswer) ? userAnswer.sort() : [];\n          return JSON.stringify(correctAnswers) === JSON.stringify(userAnswers);\n        case 'text':\n          return userAnswer.trim().toLowerCase() === correctAnswer.toLowerCase();\n        default:\n          // choice, true/false, number\n          return userAnswer.toString() === correctAnswer;\n      }\n    }\n    _restoreAnswer(questionId) {\n      const userAnswerData = this.state.userAnswers[questionId];\n      if (!userAnswerData) return;\n      const question = this.questions.find(q => q.id === questionId);\n      const qElement = this._getOrCreateQuestionElement(questionId);\n      const name = `swq-q-${question.id}`;\n      const answer = userAnswerData.answer;\n      switch (question.type) {\n        case 'choice':\n        case 'true/false':\n          const radio = qElement.querySelector(`input[name=\"${name}\"][value=\"${answer}\"]`);\n          if (radio) radio.checked = true;\n          break;\n        case 'select-multiple':\n          answer.forEach(val => {\n            const checkbox = qElement.querySelector(`input[name=\"${name}\"][value=\"${val}\"]`);\n            if (checkbox) checkbox.checked = true;\n          });\n          break;\n        case 'text':\n        case 'number':\n          const input = qElement.querySelector(`input[name=\"${name}\"]`);\n          if (input) input.value = answer;\n          break;\n      }\n    }\n    _showFeedback(question, isCorrect) {\n      const qElement = this._getOrCreateQuestionElement(question.id);\n      const feedbackEl = qElement.querySelector('.swq-feedback');\n      if (!feedbackEl) return;\n      if (isCorrect) {\n        feedbackEl.textContent = \"Correct!\";\n        feedbackEl.className = 'swq-feedback swq-feedback-correct';\n      } else {\n        if (this.config.feedbackMode === 'retry') {\n          feedbackEl.textContent = \"Incorrect. Please try again.\";\n        } else {\n          feedbackEl.textContent = `Incorrect. The correct answer is: ${question.answer}`;\n        }\n        feedbackEl.className = 'swq-feedback swq-feedback-incorrect';\n      }\n\n      // Only disable inputs in immediate mode, not in retry mode\n      if (this.config.feedbackMode === 'immediate') {\n        qElement.querySelectorAll('input').forEach(input => input.disabled = true);\n      }\n    }\n  }\n\n  // Auto-initialize on DOM load\n  document.addEventListener('DOMContentLoaded', () => {\n    swq.init('[data-swq-quiz]');\n  });\n\n  // Expose to the global window object\n  window.SWQ = window.swq = swq;\n})(window);\n\n// // Make SWQ available globally for browser use\n// if (typeof window !== 'undefined') {\n//   window.SWQ = SWQ;\n// }\n\n// Export for module systems\nif ( true && module.exports) {\n  module.exports = SWQ;\n}\n\n//# sourceURL=webpack://SWQ/./src/js/swq.js?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/swq.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});